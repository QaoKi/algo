#include <iostream>
#include <string>

using namespace std;

/*
	插入排序思想：
	回想下我们平时打扑克抓牌的过程，通常我们用右手抓牌，每抓一张牌，就放到左手上，
	抓下一张牌后，会把这张牌依次与左手上的牌比较，并把它插入到一个合适的位置（通常按照牌面大小）。
	上述的过程即为插入排序的过程，假设待排序数组为a，我们从a[1]开始，让a[1]与a[0]比较，
	若a[1]较小，则让a[1]和a[0]交换位置，此时a[0]和a[1]就相当于已经放入左手中的牌。
	然后我们再让a[2]与a[1]、a[0]比较，并为它找到一个合适的位置，
	以此类推，直到为数组的最后一个元素也找到了合适的位置
*/

/*从后往前对比数据更好
	因为如果数据已经是有序的   1 2 3 4 5
	从后往前对比，时间复杂度为O(n)
	从前往后时间复杂度变大

*/

/*
	1.插入排序的空间复杂度为 O(1)
	2.对于值相同的元素，选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，
		所以插入排序是稳定的排序算法
	3.插入排序的时间复杂度为 O(n^2)
	
*/

int main()
{

	{
		int array[10] = {8, 4, 6, 7, 2, 1, 3, 0, 9, 5};

		int len = 10;

		cout << "sort ago： ";
		for (int i = 0; i < 10; i++)
		{
			cout << array[i] << " ";
		}
		cout << endl;

		/////////////从后往前插入/////////////
		//从第2个值开始一个个的插入
		for (int i = 1; i < len; i++)
		{
			int j = i - 1;
			int temp = array[i]; //要存下来，不然 array[i] 的值会变
			for (; j >= 0; j--)
			{
				//如果j位置的值比要插入的数大，让j位置的数后移
				if (array[j] > temp)
					//这里会改变 array[i] 的值，所以 array[i] 要事先存下来
					array[j + 1] = array[j];
				else
					break;
			}

			//此时 j + 1 是该值 可以插入的位置
			array[j + 1] = temp;
		}

		cout << "sort after： ";
		for (int i = 0; i < 10; i++)
		{
			cout << array[i] << " ";
		}
		cout << endl;
		///////////////////////////////////////
	}

	{
		int array2[10] = {8, 4, 6, 7, 2, 1, 3, 0, 9, 5};

		int len = 10;

		/////////////改进版：直接插入排序，从后往前对比数据，如果发现前面那个数据比后面那个数据大，直接交换/////////////
		int i, j;
		for (i = 1; i < len; i++)
		{
			for (int j = i - 1; j >= 0 && array2[j] > array2[j + 1]; j--)
			{
				//直接交换
				int tem = array2[j];
				array2[j] = array2[j + 1];
				array2[j + 1] = tem;
			}
		}

		cout << "sort ago：  ";
		for (int i = 0; i < 10; i++)
		{
			cout << array2[i] << " ";
		}
		cout << endl;
		///////////////////////////////////////
	}

	return 0;
}