#include <string.h>
#include <iostream>

using namespace std;

/*
    字符串排序在实际的使用中通常会对应以下的几种情况：搜索系统，对于繁多的搜索结果需要进行一定的排序；
    通信系统，无论何种信息，都是一堆字符从一端传递到另一端；
*/

/*
    键索引计数法，作为三种字符串排序算法中两种的基础，本身也很适用于小整数键（排序的键为整数，并且数不算大）的简单排序
    键索引计数法主要分为四步：统计频率，将频率转换为索引，数据分类，回写。

    比如里面数组a={1,2,3,4,2,3,4,2,1,3,4,2,3,4}，它重复的数字比较多，不重复的只有1，2，3，4，这时就可以用此方法
    再比如有一群分别属于不同组的学生，将学生按照组别进行排序，因为组别编号是int，并且比较小，也可以用这种方法
*/

/*
    1，先统计每个键出现的频率，存放到count[]数组中：遍历数组，如果键为 key，则将count[key + 1] 加1，这里的键采用组号，
        如果总共有4个组，最大的组号为4，count[]数组的大小应为6，因为最高会用到 count[4 + 1]
    2，将频率转换为索引。使用 count[] 来计算每个键在排序结果中的起始索引位置。
        一般来说，任意给定的键的起始索引，均为所有较小的键所对应的出现频率之和
    3，借助一个辅助辅助 axu[]，将数据排好序
    4，将排好序的数据回写到原数组

    总结：其实就是计数排序，时间复杂度为 O(n)，空间复杂度为O(m + n)，m是数据中最大的值。稳定的排序
*/

//基数R:组号的范围在 0到R-1之间，所以R比最大的组号还大1
void sort(int *a, int N, int R)
{
    //多申请一个内存（实际申请的内存比最大的组号大2，因为基数R比最大的组号还大1，假设最大的组号为4，实际申请了大小为6的数组存储键的频率）
    int *count = new int[R + 1];

    //1。统计每个键出现的频率，count[0]的值总是0，在这个例子中，count[1]也为0，因为没有编号为0的组
    for (int i = 0; i < N; i++)
        count[a[i] + 1]++;
    //统计完以后，count[0] = 0，count[1] = 0，count[2] = 3，count[3] = 5，count[4] = 6，count[5] = 6

    /*2。将频率转换为索引，第一组有3个人，第二组有5个人，所以第三组的同学在排序结果数组中的起始位置为8
        多申请内存的目的就在这，这样count[i]的值，就是第i组在结果数组中的起始位置，更好理解
    */
    for (int r = 0; r < R; r++)
        count[r + 1] += count[r];
    //调整完索引以后，count[0] = 0, count[1] = 0, count[2] = 3, count[3] = 8, count[4] = 14, count[5] = 20

    //3。借助一个辅助数组，将数据排好序
    int *aux = new int[N];
    for (int i = 0; i < N; i++)
    {
        /*
            a[0] = 2，a[0]在第二组，第二组在aux中的起始位置为 count[2] = 3，数据放进去以后，让 count[2]++，这样下次
            再遇到第二组的同学，起始位置就变成了 4。
            a[1] = 3，a[1]在第三组，第三组在aux中的起始位置为 count[3] = 8，数据放进去以后，让 count[3]++，这样下次
            再遇到第三组的同学，起始位置就变成了 9。
            a[2] = 3，a[2]在第三组，此时第三组在aux中的起始位置为 count[3] = 9。。。
        */

        aux[count[a[i]]++] = a[i];
    }

    //4。再将aux[]中的数据复制回 a[]
    for (int i = 0; i < N; i++)
        a[i] = aux[i];
}

int main()
{
    //这里就直接只存储组号了
    int a[20] = {2, 3, 3, 4, 1, 3, 4, 3, 1, 2, 2, 1, 2, 4, 3, 4, 4, 2, 3, 4};
    //R比最大的组号还大1
    int R = 5;
    sort(a, 20, R);
    for (int i = 0; i < 20; i++)
        cout << a[i] << "  ";

    cout << endl;
    return 0;
}