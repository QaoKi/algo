#include <iostream>
#include <string>
#include <map>
#include <unordered_map>
#include <set>

using namespace std;

/*
	哈希函数用来打乱样本规律，哈希函数的几个性质：
	1，经典的哈希函数，输入域是无穷大的
	2，哈希函数的输出域(S域)是有穷的
	3，哈希函数不是随机函数，传入的Key相同，返回的哈希code是一样的
	4，当输入的key不一样，输出也可能一样，这就是哈希碰撞，因为输入域很大，
		输出域是有限的，就像11个数放到10个桶中，肯定有的桶中数量会超过1
	5，哈希函数的离散性：输入域中的数据，均匀的映射分布在输出域上，比如输入域有99个数
		输出域有9个桶，哈希函数完成以后，每个桶大约有10个数，是均匀的
*/

/*
	用一个哈希函数，可以改出多个哈希函数，这些哈希函数都是独立的

	比如：一个哈希函数返回16位的hashcode,可以拆成两个8位的hashcode，
	因为hashcode中每一位都是独立的，所以这两个8位hashcode也是独立的

	设前8位code为h1，后8位code为h2
	h3 = h1 * 1*h2	产生第三个哈希函数
	h4 = h1 * 2*h2	产生第四个哈希函数
		.
		.
		.

*/
/*
	哈希函数应用：
	1.安全加密
	2.唯一标识：布隆过滤器
	3.散列函数：不过散列表所使用的散列函数，更加关注散列后的值是否能平均分布
				对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，可以通过开放寻址法或者链表法解决
	4.负载均衡：实现一个会话粘滞的负载均衡算法，也就是说，需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。
				可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，
				最终得到的值就是应该被路由到的服务器编号
	5.分布式存储：一致性哈希
*/

/*
	map和set有两种构成方式，一种是hash，一种是平衡二叉搜索树，
	hash构成的map和set的查找、增加、删除的时间复杂度都是O(1)
	平衡二叉搜索树构成的map和set的查找、增加、删除的时间复杂度都是O(logN)
	但是二叉搜索树中数据是相对有序的，hash中的数据是无序的

	c++中，map的底层是红黑树，unordered_map的底层是哈希表
		   set的底层是红黑树，unordered_set的底层是哈希表
*/

int main()
{
	unordered_map<int, int> mapInt;
	return 0;
}