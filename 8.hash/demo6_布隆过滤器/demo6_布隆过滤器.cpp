#include <iostream>
#include <string>

using namespace std;

/*
	题目：
		假设某搜索公司，有100亿条url黑名单，每条url64字节，当用户访问某url时，、
		如果用户输入的url在这100亿条之中，就返回false，否则返回true
*/

/*
	思路：
		把100亿条，每条64字节的数据全部放到hashSet中，用户输入就去搜索看看在不在，
		但是这样内存太大，肯定是不合适的
		采用布隆过滤器，假设请求一个长度为m的整形数组
		int arr[m];	一共是4*m个字节，一个字节是8个bit，所以
		一共是32*m个bit， 每一个bit是0或者1，设 num为32*m
		所以，arr一共能表示num长的二进制

		让每条url去经过一个哈希函数，返回一个hashcode，让hashcode % num，得到的值记为temp，
		再让temp / 32，得到的值记为index,再让temp % 32，得到的值记为i，让arr[index]的第i个二进制位变为1
		100亿条数据，在0~num上均匀分布，再找k个哈希函数，
		求出hashcode，再让hashcode % num，得到的值，在arr中变为1

		当用户输入一个url，url分别进行k个哈希函数，得到k个hashcode，判断arr中这k个位置的值
		如果都是1，那么，这条url肯定在黑名单中，如果有一个不是1，说明不在

		这样是存在误差的，因为如果m比较小，哈希碰撞很大，arr中基本都变成了1，此时误差很大
		所以m越大，哈希碰撞就越小，误差率就越小,数组的大小，和能接受的失误率有关系

		用布隆过滤器，判断出 数据不在，则100%不在，是不会出现误差的，出现误差的情况是发生在
		布隆过滤器判断出 数据在 的情况

		这样的好处是不管url的字节是多少，也不管HashCode多大，都会均匀分布在0~num上


		num应该开辟多少：num为bit
		公式   num = - n*ln(p)/(ln2)^2	 n为样本量，p为可以接受的误差率

		哈希函数的个数k：
		k = ln2 * num/n = 0.7 * num/n

		在实际中，空间可能比num算出来的更大，k也可能比算出来的更多
		所以，当num和k确定了之后，实际的误差率为
			（1 - e^(-n*k/num)）^k
		
*/

int main()
{
	/*
		假设申请一个大小为1000的数组，那么一共有32000个bit
		一个url专为hashcode，hashcode % 32000之后为30000
		要把30000位置的bit设为1
	*/
	int arr[1000] = {0};
	int index = 30000; //	把30000位置设为1
	//一个数是32bit，求出第30000个bit在0~999中哪个下标下面,一共1000个桶，看看在哪个桶里面
	int intIndex = 30000 / 32;
	//一个数32个bit，求出在0~31第几号bit位，一个桶一个32个bit，看看哪个bit需要修改
	int bitIndex = 30000 % 32;

	arr[intIndex] = (arr[intIndex] | (1 << bitIndex));

	/*
		假设bitIndex为5，1<<5  的意思是000010000000...只有5号位置变为1，其余全是0
		或运算：两个数只要有一个为1，结果为1，否则为0
		一个数num与0000100000执行或运算，如果num原来5号位置为0，现在变为1，原来为1，
		则还是1，因为只有5号位置为1，其余位置为0，所以其余位置不会影响num
	*/

	return 0;
}